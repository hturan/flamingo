<!DOCTYPE html>
<html>
<head>
	<title>flamingo</title>
	<script src="js/three.js"></script>

	<style type="text/css">
		html, body {
			height: 100%;
			width: 100%;
			position: relative;
			margin: 0;
			padding: 0;
			border: 0;
			overflow: hidden;
		}

		div#fps {
			position: absolute;
			top: 10px;
			left: 10px;
			font-family: Courier;
			font-weight: bold;
			color: rgba(0,0,0,0.2);
		}
	</style>
</head>
<body>
	<div id="fps"></div>
	<div id="container"></div>

	<script type="x-shader/x-vertex" id="vertexShader">

		varying vec3 vWorldPosition;

		void main() {

			vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
			vWorldPosition = worldPosition.xyz;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}

	</script>

	<script type="x-shader/x-fragment" id="fragmentShader">

		uniform vec3 topColor;
		uniform vec3 bottomColor;
		uniform float offset;
		uniform float exponent;

		varying vec3 vWorldPosition;

		void main() {

			float h = normalize( vWorldPosition + offset ).y;
			gl_FragColor = vec4( mix( bottomColor, topColor, max( pow( max( h , 0.0), exponent ), 0.0 ) ), 1.0 );

		}

	</script>

		<script>
			var camera, scene, renderer, dirLight, hemiLight;
			var morphs = [];
			var stats;

			var clock = new THREE.Clock();
			var coolDown = 0;

            var scenery = [];
            var sceneryDispersion = 2000; // how much the cubes should be scattered about
            var numSceneryObjects = 40;
			init();
			animate();

			function init() {

				var container = document.getElementById( 'container' );

				camera = new THREE.PerspectiveCamera( 30, window.innerWidth / window.innerHeight, 1, 5000 );
				camera.position.set( 0, 0, 250 );

				scene = new THREE.Scene();

				scene.fog = new THREE.Fog( 0xffffff, 1, 5000 );
				scene.fog.color.setHSL( 0.6, 0, 1 );

				// LIGHTS

				hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffff, 0.6 );
				hemiLight.color.setHSL( 0.6, 1, 0.6 );
				hemiLight.groundColor.setHSL( 0.095, 1, 0.75 );
				hemiLight.position.set( 0, 500, 0 );
				scene.add( hemiLight );

				//

				dirLight = new THREE.DirectionalLight( 0xffffff, 1 );
				dirLight.color.setHSL( 0.1, 1, 0.95 );
				dirLight.position.set( -1, 1.75, 1 );
				dirLight.position.multiplyScalar( 50 );
				scene.add( dirLight );

				dirLight.castShadow = true;

				dirLight.shadowMapWidth = 2048;
				dirLight.shadowMapHeight = 2048;

				var d = 50;

				dirLight.shadowCameraLeft = -d;
				dirLight.shadowCameraRight = d;
				dirLight.shadowCameraTop = d;
				dirLight.shadowCameraBottom = -d;

				dirLight.shadowCameraFar = 3500;
				dirLight.shadowBias = -0.0001;
				dirLight.shadowDarkness = 0.35;
				// dirLight.shadowCameraVisible = true;

				// GROUND

				var groundGeo = new THREE.PlaneBufferGeometry( 10000, 10000 );
				var groundMat = new THREE.MeshPhongMaterial( { color: 0xffffff, specular: 0x050505 } );
				groundMat.color.setRGB( 0.98, 0.93, 0.69 );

				var ground = new THREE.Mesh( groundGeo, groundMat );
				ground.rotation.x = -Math.PI/2;
				ground.position.y = -33;
				scene.add( ground );

				ground.receiveShadow = true;

                // CUBES

                var geometry = new THREE.BoxGeometry( 6, 6, 6 );
				var material = new THREE.MeshPhongMaterial( { color: 0xddaabb, specular:  0x050505, shininess: 20, vertexColors: 0xddaabb, shading: THREE.FlatShading } );

                //var material = new THREE.MeshBasicMaterial( {color: 0xddaabb, specular: 0x050505 } );
                for (var i=0;i<numSceneryObjects;i++) {
                    var cube = new THREE.Mesh(geometry, material);
                    cube.position.y = -33 + Math.random();

                    cube.position.x = (-0.5 + Math.random())*sceneryDispersion;
                    cube.position.z = camera.position.z-Math.random()*sceneryDispersion; // spawn the cubes only in front of the camera
                    cube.rotation.x = -Math.PI / 4;
                    cube.rotation.y = -Math.PI / 4;
                    cube.rotation.z = Math.random() * 2 * Math.PI;
					var s = 1+Math.random();
					cube.scale.set( s, s, s );
                    cube.castShadow = true;
                    cube.receiveShadow = true;
                    scenery.push(cube);
                    scene.add(cube);
                }
				// SKYDOME

				var vertexShader = document.getElementById( 'vertexShader' ).textContent;
				var fragmentShader = document.getElementById( 'fragmentShader' ).textContent;
				var uniforms = {
					topColor: 	 { type: "c", value: new THREE.Color( 0x0077ff ) },
					bottomColor: { type: "c", value: new THREE.Color( 0xffffff ) },
					offset:		 { type: "f", value: 33 },
					exponent:	 { type: "f", value: 0.6 }
				};
				uniforms.topColor.value.copy( hemiLight.color );

				scene.fog.color.copy( uniforms.bottomColor.value );

				var skyGeo = new THREE.SphereGeometry( 4000, 32, 15 );
				var skyMat = new THREE.ShaderMaterial( { vertexShader: vertexShader, fragmentShader: fragmentShader, uniforms: uniforms, side: THREE.BackSide } );

				var sky = new THREE.Mesh( skyGeo, skyMat );
				scene.add( sky );

				// MODEL

				var loader = new THREE.JSONLoader();
				var models = {
					"flamingo":"models/animated/flamingo.js",
					"parrot":"models/animated/parrot.js",
					"stork":"models/animated/stork.js",
					"horse":"models/animated/horse.js"};
					
				loader.load( models["parrot"], function( geometry ) {

					morphColorsToFaceColors( geometry );
					geometry.computeMorphNormals();

					var material = new THREE.MeshPhongMaterial( { color: 0xffffff, specular: 0xffffff, shininess: 20, morphTargets: true, morphNormals: true, vertexColors: THREE.FaceColors, shading: THREE.FlatShading } );
					var meshAnim = new THREE.MorphAnimMesh( geometry, material );

					window.meshAnim = meshAnim;

					meshAnim.duration = 1000;

					var s = 0.35;
					meshAnim.scale.set( s, s, s );
					meshAnim.position.y = 15;
					// meshAnim.rotation.y = -1;

					meshAnim.castShadow = true;
					meshAnim.receiveShadow = true;
					scene.add( meshAnim );
					morphs.push( meshAnim );

				} );

				// RENDERER

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setClearColor( scene.fog.color );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );

				renderer.gammaInput = true;
				renderer.gammaOutput = true;

				renderer.shadowMapEnabled = true;
				renderer.shadowMapCullFace = THREE.CullFaceBack;

				window.addEventListener( 'resize', onWindowResize, false );
				document.addEventListener( 'keydown', onKeyDown, false );
				document.addEventListener( 'keyup', onKeyUp, false );
			}

			function morphColorsToFaceColors( geometry ) {

				if ( geometry.morphColors && geometry.morphColors.length ) {

					var colorMap = geometry.morphColors[ 0 ];

					for ( var i = 0; i < colorMap.colors.length; i ++ ) {

						geometry.faces[ i ].color = colorMap.colors[ i ];

					}

				}

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function onKeyDown ( event ) {

				switch ( event.keyCode ) {

					case 72: /*h*/

					hemiLight.visible = !hemiLight.visible;
					break;

					case 68: /*d*/

					dirLight.visible = !dirLight.visible;
					break;
					
					case 65: /*a*/
					console.log('a')
					break;
					
					// space
					case 32:
					playerKeys["s"] = 1;
					console.log("bullet");
					break;
					// arrow keys
					case 37:
					playerKeys["l"] = 1;
					break;
					case 39:
					playerKeys["r"] = 1;
					break;
					case 38:
					playerKeys["d"] = 1;
					break;
					case 40:
					playerKeys["u"] = 1;
					break;
				}

			}
			function onKeyUp ( event ) {

				switch ( event.keyCode ) {
					case 37:
					playerKeys["l"] = 0;
					break;
					case 39:
					playerKeys["r"] = 0;
					break;
					case 38:
					playerKeys["d"] = 0;
					break;
					case 40:
					playerKeys["u"] = 0;
					break;
				}
			}
			function animate() {

				requestAnimationFrame( animate );

				render();

				document.getElementById('fps').innerText = fps.getFPS();
			}
			
			function render() {

				var delta = clock.getDelta();

				//controls.update();

				for ( var i = 0; i < morphs.length; i ++ ) {

					morph = morphs[ i ];
					morph.updateAnimation( 1000 * delta );

				}
				// harleys merge
				window.meshAnim.translateZ(0.5*4);
                var maxRotationSpeed = Math.PI/180; // = 30 degrees
                var rotationDamping = 0.9;

                /*var rotationDiff = (playerRotation.x - window.meshAnim.rotation.x) % (Math.PI*2);
                if (rotationDiff>Math.PI) {rotationDiff=Math.PI*2-rotationDiff;}
                rotationDiff = Math.min(maxRotationSpeed,Math.max(-maxRotationSpeed,rotationDiff*rotationDamping));
				window.meshAnim.rotation.x += rotationDiff;
                rotationDiff = (playerRotation.x - window.meshAnim.rotation.x) % (Math.PI*2);
                if (rotationDiff>Math.PI) {rotationDiff=Math.PI*2-rotationDiff;}
                rotationDiff = Math.min(maxRotationSpeed,Math.max(-maxRotationSpeed,rotationDiff*rotationDamping));
				window.meshAnim.rotation.y += rotationDiff;
                rotationDiff = (playerRotation.z - window.meshAnim.rotation.z) % (Math.PI*2);
                if (rotationDiff>Math.PI) {rotationDiff=Math.PI*2-rotationDiff;}
                rotationDiff = Math.min(maxRotationSpeed,Math.max(-maxRotationSpeed,rotationDiff*rotationDamping));
				window.meshAnim.rotation.z += rotationDiff;
*/
                // print (rounded) rotation
                //console.log(Math.round(window.meshAnim.rotation.x*10)/10 + ", " + Math.round(window.meshAnim.rotation.y*10)/10 + ", " + Math.round(window.meshAnim.rotation.z*10)/10 )

                var cutoffZ = camera.position.z-sceneryDispersion; // furthest distance the scenery gets before respawning
                scenery.forEach(function(entry) {
                    entry.position.z -= window.meshAnim.position.z; // move so meshAnim is stationary
                    if (entry.position.z<cutoffZ) {
                        entry.position.z += sceneryDispersion;
                        entry.position.x = camera.position.x+(-0.5 + Math.random())*sceneryDispersion;
                    }
                    if (entry.position.z>camera.position.z) {
                        entry.position.z -= sceneryDispersion;
                        entry.position.x = camera.position.x+(-0.5 + Math.random())*sceneryDispersion;
                    }
                });
                window.meshAnim.position.z = 0;
				

                // third quaternion method! D:
                var q=new THREE.Quaternion;
                // X - left and right rotation, first check if the keys are being pressed but not both at once:
                if (!(playerKeys["l"] && playerKeys["r"]) && (playerKeys["l"] || playerKeys["r"])) {
                    q.setFromAxisAngle(new THREE.Vector3(0, 1, 0),
                                    (playerKeys["l"] - playerKeys["r"]) * delta);
                    window.meshAnim.quaternion.multiply(q);
                }
                // Y - up and down rotation, first check if the keys are being pressed but not both at once:
                if (!(playerKeys["u"] && playerKeys["d"]) && (playerKeys["u"] || playerKeys["d"])) {
                    q.setFromAxisAngle(new THREE.Vector3(1, 0, 0),
                                    (playerKeys["u"] - playerKeys["d"]) * delta);
                    window.meshAnim.quaternion.multiply(q);
                }


                // do client shit after so it works?
                if (playerRotation.enabled) {
                    var euler = new THREE.Euler();
                    var zee = new THREE.Vector3(0, 0, 1);

                    var q0 = new THREE.Quaternion();
                    var q1 = new THREE.Quaternion(0, 0, 0, 1); // - PI/2 around the x-axis

                    euler.set(playerRotation.b, playerRotation.a, -playerRotation.g, 'YXZ');                       // 'ZXY' for the device, but 'YXZ' for us
                    q1.setFromEuler(euler);                               // orient the device
                    q1.multiply(q0.setFromAxisAngle(zee, -playerRotation.o));    // adjust for screen orientation
                    //smooth (slerp) dat quat!
                    window.meshAnim.quaternion.slerp(q1, Math.min(1, delta * 10));
                }
                // print (rounded) quaternion
                //console.log(Math.round(window.meshAnim.quaternion.x*10)/10 + ", " + Math.round(window.meshAnim.quaternion.y*10)/10 + ", " + Math.round(window.meshAnim.quaternion.z*10)/10+ ", " + Math.round(window.meshAnim.quaternion.w*10)/10 + "  : " + Math.round(playerRotation.a*10)/10 + ", "+ Math.round(playerRotation.b*10)/10 + ", "+ Math.round(playerRotation.g*10)/10 + ", "+ Math.round(playerRotation.o*10)/10   )

				//bullet
				coolDown += delta ;
				if (playerKeys["s"]) {
					//console.log("shot " + coolDown);
					if (coolDown > 0.5) {
						//console.log("reset cooldown");
						shootBullet(window.meshAnim.position, window.meshAnim.position);
						coolDown = 0;
						playerKeys["s"] = 0;
					}
				}
                camera.position.x = window.meshAnim.position.x;
                camera.lookAt(window.meshAnim.position);

				renderer.render( scene, camera );

			}
			//bullets = [];
			var bulletGeometry = new THREE.SphereGeometry(75, 32, 32 );
			var bulletMaterial = new THREE.MeshBasicMaterial( {color: 0x000000} );
			function shootBullet( pos, vel) {
				console.log("shot bullet from " + pos.x + "," + pos.y + "," +  pos.z);
				var bulletMesh = new THREE.Mesh( bulletGeometry, bulletMaterial );
				bulletMesh.castShadow = true;
				bulletMesh.receiveShadow = true;
				bulletMesh.position.copy(pos);
				//bullets.push(bulletMesh);
				scene.add(bulletMesh);
                console.log(bulletMesh);
                console.log(pos);
                camera.lookAt(pos);
			}


	</script>

	<script type="text/javascript">
		var ws = new WebSocket(location.origin.replace(/^http/, 'ws'));

		ws.onopen = function () {
      ws.send(JSON.stringify({client_type: 'renderer'}));
      webSocketActive = true;
    };

		var playerPosition = {x:0, y:0, z:0};
		var playerRotation = {a:0, b:0, g:0, o:0,enabled:false};
		var playerKeys = {"u":0,"d":0,"l":0,"r":0,"s":0};

		ws.addEventListener("message", function(response) {
			var response = JSON.parse(response.data);

			switch (response.event) {
				case 'x.press':
					break;
				case 'x.release':
					break;
				case 'left.move':
					playerPosition.x = (response.data.x - 128) / 100;
					playerPosition.y = (response.data.y - 128) / 100;
					break;
				case 'motion':
					var rotation = response.data.value;
                    playerRotation.a = THREE.Math.degToRad( rotation.a );
                    playerRotation.b = THREE.Math.degToRad( rotation.b );
                    playerRotation.g = THREE.Math.degToRad( rotation.g );
                    playerRotation.o = THREE.Math.degToRad( rotation.o );
                    playerRotation.enabled = true;
                    console.log(Math.round(playerRotation.a*100)/100 + ", "+ Math.round(playerRotation.b*100)/100 + ", "+ Math.round(playerRotation.g*100)/100 + ", "+ Math.round(playerRotation.o*100)/100   );
/*
					playerRotation.x = -THREE.Math.degToRad(rotation.x);
					playerRotation.y = THREE.Math.degToRad(rotation.y);
					playerRotation.z = -THREE.Math.degToRad(rotation.z);
*/
					break;
			}
		});

		var fps = {
			startTime : 0,
			frameNumber : 0,
			getFPS : function(){
				this.frameNumber++;
				var d = new Date().getTime(),
					currentTime = ( d - this.startTime ) / 1000,
					result = Math.floor( ( this.frameNumber / currentTime ) );

				if( currentTime > 1 ){
					this.startTime = new Date().getTime();
					this.frameNumber = 0;
				}
				return result;
			}	
		};
	</script>
</body>
</html>